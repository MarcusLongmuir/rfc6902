{
  "version": 3,
  "sources": ["../src/index.ts", "../src/pointer.ts", "../src/util.ts", "../src/diff.ts", "../src/patch.ts"],
  "sourcesContent": ["export { Pointer } from './pointer'\nexport { applyPatch } from './patch'\nexport type { Operation, TestOperation } from './diff'\nexport { createPatch, createTests } from './diff'\n", "/**\nUnescape token part of a JSON Pointer string\n\n`token` should *not* contain any '/' characters.\n\n> Evaluation of each reference token begins by decoding any escaped\n> character sequence.  This is performed by first transforming any\n> occurrence of the sequence '~1' to '/', and then transforming any\n> occurrence of the sequence '~0' to '~'.  By performing the\n> substitutions in this order, an implementation avoids the error of\n> turning '~01' first into '~1' and then into '/', which would be\n> incorrect (the string '~01' correctly becomes '~1' after\n> transformation).\n\nHere's my take:\n\n~1 is unescaped with higher priority than ~0 because it is a lower-order escape character.\nI say \"lower order\" because '/' needs escaping due to the JSON Pointer serialization technique.\nWhereas, '~' is escaped because escaping '/' uses the '~' character.\n*/\nfunction unescape(token: string): string {\n  return token.replace(/~1/g, '/').replace(/~0/g, '~')\n}\n\n/** Escape token part of a JSON Pointer string\n\n> '~' needs to be encoded as '~0' and '/'\n> needs to be encoded as '~1' when these characters appear in a\n> reference token.\n\nThis is the exact inverse of `unescape()`, so the reverse replacements must take place in reverse order.\n*/\nfunction escape(token: string): string {\n  return token.replace(/~/g, '~0').replace(/\\//g, '~1')\n}\n\nexport interface PointerEvaluation {\n  parent: any\n  key: string\n  value: any\n}\n\n/**\nJSON Pointer representation\n*/\nexport class Pointer {\n  constructor(public tokens = ['']) { }\n  /**\n  `path` *must* be a properly escaped string.\n  */\n  static fromJSON(path: string): Pointer {\n    const tokens = path.split('/').map(unescape)\n    if (tokens[0] !== '') throw new Error(`Invalid JSON Pointer: ${path}`)\n    return new Pointer(tokens)\n  }\n  toString(): string {\n    return this.tokens.map(escape).join('/')\n  }\n  /**\n  Returns an object with 'parent', 'key', and 'value' properties.\n  In the special case that this Pointer's path == \"\",\n  this object will be {parent: null, key: '', value: object}.\n  Otherwise, parent and key will have the property such that parent[key] == value.\n  */\n  evaluate(object: any): PointerEvaluation {\n    let parent: any = null\n    let key = ''\n    let value = object\n    for (let i = 1, l = this.tokens.length; i < l; i++) {\n      parent = value\n      key = this.tokens[i]\n      if (key == '__proto__' || key == 'constructor' || key == 'prototype') {\n        continue\n      }\n      // not sure if this the best way to handle non-existant paths...\n      value = (parent || {})[key]\n    }\n    return {parent, key, value}\n  }\n  get(object: any): any {\n    return this.evaluate(object).value\n  }\n  set(object: any, value: any): void {\n    let cursor: any = object\n    for (let i = 1, l = this.tokens.length - 1, token = this.tokens[i]; i < l; i++) {\n      // not sure if this the best way to handle non-existant paths...\n      cursor = (cursor || {})[token]\n    }\n    if (cursor) {\n      cursor[this.tokens[this.tokens.length - 1]] = value\n    }\n  }\n  push(token: string): void {\n    // mutable\n    this.tokens.push(token)\n  }\n  /**\n  `token` should be a String. It'll be coerced to one anyway.\n\n  immutable (shallowly)\n  */\n  add(token: string): Pointer {\n    const tokens = this.tokens.concat(String(token))\n    return new Pointer(tokens)\n  }\n}\n", "export const hasOwnProperty = Object.prototype.hasOwnProperty\n\nexport function objectType(object: any) {\n  if (object === undefined) {\n    return 'undefined'\n  }\n  if (object === null) {\n    return 'null'\n  }\n  if (Array.isArray(object)) {\n    return 'array'\n  }\n  return typeof object\n}\n\nfunction isNonPrimitive(value: any): value is object {\n  // loose-equality checking for null is faster than strict checking for each of null/undefined/true/false\n  // checking null first, then calling typeof, is faster than vice-versa\n  return value != null && typeof value == 'object'\n}\n\n/**\nRecursively copy a value.\n\n@param source - should be a JavaScript primitive, Array, Date, or (plain old) Object.\n@returns copy of source where every Array and Object have been recursively\n         reconstructed from their constituent elements\n*/\nexport function clone<T extends any>(source: T): T {\n  if (!isNonPrimitive(source)) {\n    // short-circuiting is faster than a single return\n    return source\n  }\n  // x.constructor == Array is the fastest way to check if x is an Array\n  if (source.constructor == Array) {\n    // construction via imperative for-loop is faster than source.map(arrayVsObject)\n    const length = (source as Array<any>).length\n    // setting the Array length during construction is faster than just `[]` or `new Array()`\n    const arrayTarget: any = new Array(length)\n    for (let i = 0; i < length; i++) {\n      arrayTarget[i] = clone(source[i])\n    }\n    return arrayTarget\n  }\n  // Date\n  if (source.constructor == Date) {\n    const dateTarget: any = new Date(+source)\n    return dateTarget\n  }\n  // Object\n  const objectTarget: any = {}\n  // declaring the variable (with const) inside the loop is faster\n  for (const key in source) {\n    // hasOwnProperty costs a bit of performance, but it's semantically necessary\n    // using a global helper is MUCH faster than calling source.hasOwnProperty(key)\n    if (hasOwnProperty.call(source, key)) {\n      objectTarget[key] = clone(source[key])\n    }\n  }\n  return objectTarget\n}\n", "import {Pointer} from './pointer' // we only need this for type inference\nimport {hasOwnProperty, objectType} from './util'\nimport equal from 'deep-equal';\n\n/**\nAll diff* functions should return a list of operations, often empty.\n\nEach operation should be an object with two to four fields:\n* `op`: the name of the operation; one of \"add\", \"remove\", \"replace\", \"move\",\n  \"copy\", or \"test\".\n* `path`: a JSON pointer string\n* `from`: a JSON pointer string\n* `value`: a JSON value\n\nThe different operations have different arguments.\n* \"add\": [`path`, `value`]\n* \"remove\": [`path`]\n* \"replace\": [`path`, `value`]\n* \"move\": [`from`, `path`]\n* \"copy\": [`from`, `path`]\n* \"test\": [`path`, `value`]\n\nCurrently this only really differentiates between Arrays, Objects, and\nEverything Else, which is pretty much just what JSON substantially\ndifferentiates between.\n*/\n\nexport interface AddOperation     { op: 'add',     path: string, value: any    }\nexport interface RemoveOperation  { op: 'remove',  path: string                }\nexport interface ReplaceOperation { op: 'replace', path: string, value: any    }\nexport interface MoveOperation    { op: 'move',    from: string, path: string  }\nexport interface CopyOperation    { op: 'copy',    from: string, path: string  }\nexport interface TestOperation    { op: 'test',    path: string, value: any    }\n\nexport type Operation = AddOperation |\n                        RemoveOperation |\n                        ReplaceOperation |\n                        MoveOperation |\n                        CopyOperation |\n                        TestOperation\n\nexport function isDestructive({op}: Operation): boolean {\n  return op === 'remove' || op === 'replace' || op === 'copy' || op === 'move'\n}\n\nexport type Diff = (input: any, output: any, ptr: Pointer) => Operation[]\n/**\nVoidableDiff exists to allow the user to provide a partial diff(...) function,\nfalling back to the built-in diffAny(...) function if the user-provided function\nreturns void.\n*/\nexport type VoidableDiff = (input: any, output: any, ptr: Pointer) => Operation[] | void\n\nfunction wrapVoidableDiff(diff: VoidableDiff): Diff {\n  function wrappedDiff(input: any, output: any, ptr: Pointer): Operation[] {\n    const custom_patch = diff(input, output, ptr)\n    // ensure an array is always returned\n    return Array.isArray(custom_patch) ? custom_patch : diffAny(input, output, ptr, wrappedDiff)\n  }\n  return wrappedDiff\n}\n\n/**\n Create a test operation based on `input`'s current evaluation of the JSON\n Pointer `path`; if such a pointer cannot be resolved, returns undefined.\n */\nfunction createTest(input: any, path: string): TestOperation | undefined {\n  const endpoint = Pointer.fromJSON(path).evaluate(input)\n  if (endpoint !== undefined) {\n    return {op: 'test', path, value: endpoint.value}\n  }\n}\n\n/**\n Produce an 'application/json-patch+json'-type list of tests, to verify that\n existing values in an object are identical to the those captured at some\n checkpoint (whenever this function is called).\n\n This does not alter `input` or `output` unless they have a property getter with\n side-effects (which is not a good idea anyway).\n\n Returns list of test operations.\n */\nexport function createTests(input: any, patch: Operation[]): TestOperation[] {\n  const tests = new Array<TestOperation>()\n  patch.filter(isDestructive).forEach(operation => {\n    const pathTest = createTest(input, operation.path)\n    if (pathTest) tests.push(pathTest)\n    if ('from' in operation) {\n      const fromTest = createTest(input, operation.from)\n      if (fromTest) tests.push(fromTest)\n    }\n  })\n  return tests\n}\n\n\n/**\n Produce a 'application/json-patch+json'-type patch to get from one object to\n another.\n\n This does not alter `input` or `output` unless they have a property getter with\n side-effects (which is not a good idea anyway).\n\n `diff` is called on each pair of comparable non-primitive nodes in the\n `input`/`output` object trees, producing nested patches. Return `undefined`\n to fall back to default behaviour.\n\n Returns list of operations to perform on `input` to produce `output`.\n */\nexport function createPatch(input: any, output: any, diff?: VoidableDiff): Operation[] {\n  const ptr = new Pointer()\n  // a new Pointer gets a default path of [''] if not specified\n  return (diff ? wrapVoidableDiff(diff) : diffAny)(input, output, ptr)\n}\n\n/**\nList the keys in `minuend` that are not in `subtrahend`.\n\nA key is only considered if it is both 1) an own-property (o.hasOwnProperty(k))\nof the object, and 2) has a value that is not undefined. This is to match JSON\nsemantics, where JSON object serialization drops keys with undefined values.\n\n@param minuend Object of interest\n@param subtrahend Object of comparison\n@returns Array of keys that are in `minuend` but not in `subtrahend`.\n*/\nexport function subtract(minuend: {[index: string]: any}, subtrahend: {[index: string]: any}): string[] {\n  // initialize empty object; we only care about the keys, the values can be anything\n  const obj: {[index: string]: number} = {}\n  // build up obj with all the properties of minuend\n  for (const add_key in minuend) {\n    if (hasOwnProperty.call(minuend, add_key) && minuend[add_key] !== undefined) {\n      obj[add_key] = 1\n    }\n  }\n  // now delete all the properties of subtrahend from obj\n  // (deleting a missing key has no effect)\n  for (const del_key in subtrahend) {\n    if (hasOwnProperty.call(subtrahend, del_key) && subtrahend[del_key] !== undefined) {\n      delete obj[del_key]\n    }\n  }\n  // finally, extract whatever keys remain in obj\n  return Object.keys(obj)\n}\n\n/**\nList the keys that shared by all `objects`.\n\nThe semantics of what constitutes a \"key\" is described in {@link subtract}.\n\n@param objects Array of objects to compare\n@returns Array of keys that are in (\"own-properties\" of) every object in `objects`.\n*/\nexport function intersection(objects: ArrayLike<{[index: string]: any}>): string[] {\n  const length = objects.length\n  // prepare empty counter to keep track of how many objects each key occurred in\n  const counter: {[index: string]: number} = {}\n  // go through each object and increment the counter for each key in that object\n  for (let i = 0; i < length; i++) {\n    const object = objects[i]\n    for (const key in object) {\n      if (hasOwnProperty.call(object, key) && object[key] !== undefined) {\n        counter[key] = (counter[key] || 0) + 1\n      }\n    }\n  }\n  // now delete all keys from the counter that were not seen in every object\n  for (const key in counter) {\n    if (counter[key] < length) {\n      delete counter[key]\n    }\n  }\n  // finally, extract whatever keys remain in the counter\n  return Object.keys(counter)\n}\n\ninterface ArrayAdd     { op: 'add',     index: number, value: any }\ninterface ArrayRemove  { op: 'remove',  index: number }\ninterface ArrayReplace { op: 'replace', index: number, original: any, value: any }\n/** These are not proper Operation objects, but will be converted into\nOperation objects eventually. {index} indicates the actual target position,\nnever 'end-of-array' */\ntype ArrayOperation = ArrayAdd | ArrayRemove | ArrayReplace\nfunction isArrayAdd(array_operation: ArrayOperation): array_operation is ArrayAdd {\n  return array_operation.op === 'add'\n}\nfunction isArrayRemove(array_operation: ArrayOperation): array_operation is ArrayRemove {\n  return array_operation.op === 'remove'\n}\n\ninterface DynamicAlternative {\n  /**\n   * track prev key position for less memory usage\n   */\n  prev: string | null\n  operation: ArrayOperation | null\n  /**\n  cost indicates the total cost of getting to this position.\n  */\n  cost: number\n}\n\nfunction buildOperations(memo: Array<Array<DynamicAlternative>>, i: number, j: number) {\n  var memoized: DynamicAlternative = memo[i][j]\n  if (!memoized) {\n    throw new Error('invalid memo')\n  }\n  let operations: ArrayOperation[] = []\n  while (memoized && memoized.prev && memoized.operation) {\n    operations.push(memoized.operation)\n    const index = memoized.prev.split(',')\n    memoized = memo[Number(index[0])][Number(index[1])]\n  }\n  return operations.reverse()\n}\n\n/**\nCalculate the shortest sequence of operations to get from `input` to `output`,\nusing a dynamic programming implementation of the Levenshtein distance algorithm.\n\nTo get from the input ABC to the output AZ we could just delete all the input\nand say \"insert A, insert Z\" and be done with it. That's what we do if the\ninput is empty. But we can be smarter.\n\n          output\n               A   Z\n               -   -\n          [0]  1   2\ninput A |  1  [0]  1\n      B |  2  [1]  1\n      C |  3   2  [2]\n\n1) start at 0,0 (+0)\n2) keep A (+0)\n3) remove B (+1)\n4) replace C with Z (+1)\n\nIf the `input` (source) is empty, they'll all be in the top row, resulting in an\narray of 'add' operations.\nIf the `output` (target) is empty, everything will be in the left column,\nresulting in an array of 'remove' operations.\n\n@returns A list of add/remove/replace operations.\n*/\nexport function diffArrays<T>(input: T[], output: T[], ptr: Pointer, diff: Diff = diffAny): Operation[] {\n  if (diff === void 0) { diff = diffAny; }\n  // set up cost matrix (very simple initialization: just a map)\n  var input_length = (isNaN(input.length) || input.length <= 0) ? 0 : input.length\n  var output_length = (isNaN(output.length) || output.length <= 0) ? 0 : output.length\n  var input_end = input_length\n  var output_end = output_length\n  while (input_end > 0 && output_end > 0) { // accelerate same arrays\n    if (equal(input[input_end-1], output[output_end-1])) {\n      input_end--\n      output_end--\n    } else {\n      break\n    }\n  }\n  const memo: Array<Array<DynamicAlternative>> = new Array(input_end + 1)\n  for (var i = 0; i <= input_end; i++) {\n    memo[i] = new Array(output_end + 1)\n  }\n  memo[0][0] = { prev: null, operation: null, cost: 0 }\n  /**\n  Calculate the cheapest sequence of operations required to get from\n  input.slice(0, i) to output.slice(0, j).\n  There may be other valid sequences with the same cost, but none cheaper.\n\n  @param i The row in the layout above\n  @param j The column in the layout above\n  @returns An object containing a list of operations, along with the total cost\n           of applying them (+1 for each add/remove/replace operation)\n  */\n  // handle weird objects masquerading as Arrays that don't have proper length\n  // properties by using 0 for everything but positive numbers\n  for (let i = 0; i <= input_end; i++) {\n    for (let j = 0; j <= output_end; j++) {\n      var memoized = memo[i][j]\n      if (memoized) continue\n      const add_prev_key = `${i},${j - 1}`\n      const remove_prev_key = `${i - 1},${j}`\n      const replace_prev_key = `${i - 1},${j - 1}`\n      var remove_operation: ArrayRemove = {\n        op: 'remove',\n        index: i - 1,\n      }\n      var add_operation: ArrayAdd = {\n        op: 'add',\n        index: i - 1,\n        value: output[j - 1],\n      }\n      \n      if (j === 0) {\n        memoized = { prev: remove_prev_key, operation: remove_operation, cost: memo[i - 1][j].cost + 1 }\n      } else if (i === 0) {\n        memoized = { prev: add_prev_key, operation: add_operation, cost: memo[i][j - 1].cost + 1 }\n      } else {\n        if (equal(input[i - 1], output[j - 1])) {\n          memoized = memo[i - 1][j - 1]\n        } else {\n          const remove_prev = memo[i - 1][j]\n          const add_prev = memo[i][j - 1]\n          const replace_prev = memo[i - 1][j - 1]\n          const min_cost = Math.min(replace_prev.cost, add_prev.cost, remove_prev.cost)\n          if (remove_prev.cost === min_cost) {\n            memoized = { prev: remove_prev_key, operation: remove_operation, cost: memo[i - 1][j].cost + 1 }\n          } else if (add_prev.cost === min_cost) {\n            memoized = { prev: add_prev_key, operation: add_operation, cost: memo[i][j - 1].cost + 1 }\n          } else {\n            var replace_operation: ArrayReplace = {\n              op: 'replace',\n              index: i - 1,\n              original: input[i - 1],\n              value: output[j - 1],\n            }\n            memoized = { prev: replace_prev_key, operation: replace_operation, cost: memo[i - 1][j - 1].cost + 1 }\n          }\n        }\n      }\n      memo[i][j] = memoized\n    }\n  }\n  var array_operations = buildOperations(memo, input_end, output_end)\n  const [padded_operations] = array_operations.reduce<[Operation[], number]>(([operations, padding], array_operation) => {\n    if (isArrayAdd(array_operation)) {\n      const padded_index = array_operation.index + 1 + padding\n      const index_token = padded_index < (input_length + padding) ? String(padded_index) : '-'\n      const operation = {\n        op: array_operation.op,\n        path: ptr.add(index_token).toString(),\n        value: array_operation.value,\n      }\n      // padding++ // maybe only if array_operation.index > -1 ?\n      return [operations.concat(operation), padding + 1]\n    }\n    else if (isArrayRemove(array_operation)) {\n      const operation = {\n        op: array_operation.op,\n        path: ptr.add(String(array_operation.index + padding)).toString(),\n      }\n      // padding--\n      return [operations.concat(operation), padding - 1]\n    }\n    else { // replace\n      const replace_ptr = ptr.add(String(array_operation.index + padding))\n      const replace_operations = diff(array_operation.original, array_operation.value, replace_ptr)\n      return [operations.concat(...replace_operations), padding]\n    }\n  }, [[], 0])\n  return padded_operations\n}\n\nexport function diffObjects(input: any, output: any, ptr: Pointer, diff: Diff = diffAny): Operation[] {\n  // if a key is in input but not output -> remove it\n  const operations: Operation[] = []\n  subtract(input, output).forEach(key => {\n    operations.push({op: 'remove', path: ptr.add(key).toString()})\n  })\n  // if a key is in output but not input -> add it\n  subtract(output, input).forEach(key => {\n    operations.push({op: 'add', path: ptr.add(key).toString(), value: output[key]})\n  })\n  // if a key is in both, diff it recursively\n  intersection([input, output]).forEach(key => {\n    operations.push(...diff(input[key], output[key], ptr.add(key)))\n  })\n  return operations\n}\n\n/**\n`diffAny()` returns an empty array if `input` and `output` are materially equal\n(i.e., would produce equivalent JSON); otherwise it produces an array of patches\nthat would transform `input` into `output`.\n\n> Here, \"equal\" means that the value at the target location and the\n> value conveyed by \"value\" are of the same JSON type, and that they\n> are considered equal by the following rules for that type:\n> o  strings: are considered equal if they contain the same number of\n>    Unicode characters and their code points are byte-by-byte equal.\n> o  numbers: are considered equal if their values are numerically\n>    equal.\n> o  arrays: are considered equal if they contain the same number of\n>    values, and if each value can be considered equal to the value at\n>    the corresponding position in the other array, using this list of\n>    type-specific rules.\n> o  objects: are considered equal if they contain the same number of\n>    members, and if each member can be considered equal to a member in\n>    the other object, by comparing their keys (as strings) and their\n>    values (using this list of type-specific rules).\n> o  literals (false, true, and null): are considered equal if they are\n>    the same.\n*/\nexport function diffAny(input: any, output: any, ptr: Pointer, diff: Diff = diffAny): Operation[] {\n  // strict equality handles literals, numbers, and strings (a sufficient but not necessary cause)\n  if (input === output) {\n    return []\n  }\n  const input_type = objectType(input)\n  const output_type = objectType(output)\n  if (input_type == 'array' && output_type == 'array') {\n    return diffArrays(input, output, ptr, diff)\n  }\n  if (input_type == 'object' && output_type == 'object') {\n    return diffObjects(input, output, ptr, diff)\n  }\n  // at this point we know that input and output are materially different;\n  // could be array -> object, object -> array, boolean -> undefined,\n  // number -> string, or some other combination, but nothing that can be split\n  // up into multiple patches: so `output` must replace `input` wholesale.\n  return [{op: 'replace', path: ptr.toString(), value: output}]\n}\n", "import {Pointer} from './pointer'\nimport {clone} from './util'\nimport {AddOperation,\n        RemoveOperation,\n        ReplaceOperation,\n        MoveOperation,\n        CopyOperation,\n        TestOperation,\n        Operation,\n        diffAny} from './diff'\n\nexport class MissingError extends Error {\n  constructor(public path: string) {\n    super(`Value required at path: ${path}`)\n    this.name = 'MissingError'\n  }\n}\n\nexport class TestError extends Error {\n  constructor(public actual: any, public expected: any) {\n    super(`Test failed: ${actual} != ${expected}`)\n    this.name = 'TestError'\n  }\n}\n\n/**\n Apply a 'application/json-patch+json'-type patch to an object.\n\n `patch` *must* be an array of operations.\n\n > Operation objects MUST have exactly one \"op\" member, whose value\n > indicates the operation to perform.  Its value MUST be one of \"add\",\n > \"remove\", \"replace\", \"move\", \"copy\", or \"test\"; other values are\n > errors.\n\n This method mutates the target object in-place.\n\n @returns list of results, one for each operation: `null` indicated success,\n otherwise, the result will be an instance of one of the Error classes:\n MissingError, InvalidOperationError, or TestError.\n */\nexport function applyPatch(object: any, patch: Operation[]) {\n  return patch.map(operation => apply(object, operation))\n}\n\nfunction _add(object: any, key: string, value: any): void {\n  if (Array.isArray(object)) {\n    // `key` must be an index\n    if (key == '-') {\n      object.push(value)\n    }\n    else {\n      const index = parseInt(key, 10)\n      object.splice(index, 0, value)\n    }\n  }\n  else {\n    object[key] = value\n  }\n}\n\nfunction _remove(object: any, key: string): void {\n  if (Array.isArray(object)) {\n    // '-' syntax doesn't make sense when removing\n    const index = parseInt(key, 10)\n    object.splice(index, 1)\n  }\n  else {\n    // not sure what the proper behavior is when path = ''\n    delete object[key]\n  }\n}\n\n/**\n>  o  If the target location specifies an array index, a new value is\n>     inserted into the array at the specified index.\n>  o  If the target location specifies an object member that does not\n>     already exist, a new member is added to the object.\n>  o  If the target location specifies an object member that does exist,\n>     that member's value is replaced.\n*/\nexport function add(object: any, operation: AddOperation): MissingError | null {\n  const endpoint = Pointer.fromJSON(operation.path).evaluate(object)\n  // it's not exactly a \"MissingError\" in the same way that `remove` is -- more like a MissingParent, or something\n  if (endpoint.parent === undefined) {\n    return new MissingError(operation.path)\n  }\n  _add(endpoint.parent, endpoint.key, clone(operation.value))\n  return null\n}\n\n/**\n> The \"remove\" operation removes the value at the target location.\n> The target location MUST exist for the operation to be successful.\n*/\nexport function remove(object: any, operation: RemoveOperation): MissingError | null {\n  // endpoint has parent, key, and value properties\n  const endpoint = Pointer.fromJSON(operation.path).evaluate(object)\n  if (endpoint.value === undefined) {\n    return new MissingError(operation.path)\n  }\n  // not sure what the proper behavior is when path = ''\n  _remove(endpoint.parent, endpoint.key)\n  return null\n}\n\n/**\n> The \"replace\" operation replaces the value at the target location\n> with a new value.  The operation object MUST contain a \"value\" member\n> whose content specifies the replacement value.\n> The target location MUST exist for the operation to be successful.\n\n> This operation is functionally identical to a \"remove\" operation for\n> a value, followed immediately by an \"add\" operation at the same\n> location with the replacement value.\n\nEven more simply, it's like the add operation with an existence check.\n*/\nexport function replace(object: any, operation: ReplaceOperation): MissingError | null {\n  const endpoint = Pointer.fromJSON(operation.path).evaluate(object)\n  if (endpoint.parent === null) {\n    return new MissingError(operation.path)\n  }\n  // this existence check treats arrays as a special case\n  if (Array.isArray(endpoint.parent)) {\n    if (parseInt(endpoint.key, 10) >= endpoint.parent.length) {\n      return new MissingError(operation.path)\n    }\n  }\n  else if (endpoint.value === undefined) {\n    return new MissingError(operation.path)\n  }\n  endpoint.parent[endpoint.key] = operation.value\n  return null\n}\n\n/**\n> The \"move\" operation removes the value at a specified location and\n> adds it to the target location.\n> The operation object MUST contain a \"from\" member, which is a string\n> containing a JSON Pointer value that references the location in the\n> target document to move the value from.\n> This operation is functionally identical to a \"remove\" operation on\n> the \"from\" location, followed immediately by an \"add\" operation at\n> the target location with the value that was just removed.\n\n> The \"from\" location MUST NOT be a proper prefix of the \"path\"\n> location; i.e., a location cannot be moved into one of its children.\n\nTODO: throw if the check described in the previous paragraph fails.\n*/\nexport function move(object: any, operation: MoveOperation): MissingError | null {\n  const from_endpoint = Pointer.fromJSON(operation.from).evaluate(object)\n  if (from_endpoint.value === undefined) {\n    return new MissingError(operation.from)\n  }\n  const endpoint = Pointer.fromJSON(operation.path).evaluate(object)\n  if (endpoint.parent === undefined) {\n    return new MissingError(operation.path)\n  }\n  _remove(from_endpoint.parent, from_endpoint.key)\n  _add(endpoint.parent, endpoint.key, from_endpoint.value)\n  return null\n}\n\n/**\n> The \"copy\" operation copies the value at a specified location to the\n> target location.\n> The operation object MUST contain a \"from\" member, which is a string\n> containing a JSON Pointer value that references the location in the\n> target document to copy the value from.\n> The \"from\" location MUST exist for the operation to be successful.\n\n> This operation is functionally identical to an \"add\" operation at the\n> target location using the value specified in the \"from\" member.\n\nAlternatively, it's like 'move' without the 'remove'.\n*/\nexport function copy(object: any, operation: CopyOperation): MissingError | null {\n  const from_endpoint = Pointer.fromJSON(operation.from).evaluate(object)\n  if (from_endpoint.value === undefined) {\n    return new MissingError(operation.from)\n  }\n  const endpoint = Pointer.fromJSON(operation.path).evaluate(object)\n  if (endpoint.parent === undefined) {\n    return new MissingError(operation.path)\n  }\n  _add(endpoint.parent, endpoint.key, clone(from_endpoint.value))\n  return null\n}\n\n/**\n> The \"test\" operation tests that a value at the target location is\n> equal to a specified value.\n> The operation object MUST contain a \"value\" member that conveys the\n> value to be compared to the target location's value.\n> The target location MUST be equal to the \"value\" value for the\n> operation to be considered successful.\n*/\nexport function test(object: any, operation: TestOperation): TestError | null {\n  const endpoint = Pointer.fromJSON(operation.path).evaluate(object)\n  // TODO: this diffAny(...).length usage could/should be lazy\n  if (diffAny(endpoint.value, operation.value, new Pointer()).length) {\n    return new TestError(endpoint.value, operation.value)\n  }\n  return null\n}\n\nexport class InvalidOperationError extends Error {\n  constructor(public operation: Operation) {\n    super(`Invalid operation: ${operation.op}`)\n    this.name = 'InvalidOperationError'\n  }\n}\n\n/**\nSwitch on `operation.op`, applying the corresponding patch function for each\ncase to `object`.\n*/\nexport function apply(object: any, operation: Operation): MissingError | InvalidOperationError | TestError | null {\n  // not sure why TypeScript can't infer typesafety of:\n  //   {add, remove, replace, move, copy, test}[operation.op](object, operation)\n  // (seems like a bug)\n  switch (operation.op) {\n    case 'add':     return add(object, operation)\n    case 'remove':  return remove(object, operation)\n    case 'replace': return replace(object, operation)\n    case 'move':    return move(object, operation)\n    case 'copy':    return copy(object, operation)\n    case 'test':    return test(object, operation)\n  }\n  return new InvalidOperationError(operation)\n}\n"],
  "mappings": "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",
  "names": ["equal", "i"]
}
